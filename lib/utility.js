// Generated by CoffeeScript 1.6.3
(function() {
  var assert, buildCoffee, copy, copyMetadata, cp, exec, exports, fs, isDirectory, isFile, isMatch, list, makeDirectories, makeParentDirectories, np, read, spawn, touch, watchCoffee, write;

  require('sugar');

  fs = require('fs');

  np = require('path');

  cp = require('child_process');

  module.exports = exports = {
    spawn: spawn = function(command, options, callback) {
      var args, child;
      if (command == null) {
        return typeof callback === "function" ? callback() : void 0;
      }
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      if (options == null) {
        options = {};
      }
      if (options.stdio == null) {
        options.stdio = 'inherit';
      }
      args = command.split(/\s+/);
      command = args.shift();
      child = cp.spawn(command, args, options);
      if (callback != null) {
        child.on('exit', callback);
      }
      return child;
    },
    exec: exec = function(command, options, callback) {
      if (command == null) {
        return typeof callback === "function" ? callback() : void 0;
      }
      if (typeof options === 'function') {
        callback = options;
        options = null;
      }
      if (options == null) {
        options = {};
      }
      return cp.exec(command, options, function(err, stdout, stderr) {
        if (err != null) {
          console.log(err);
        }
        if (stdout != null) {
          console.log(stdout.toString());
        }
        if (stderr != null) {
          console.log(stderr.toString());
        }
        return typeof callback === "function" ? callback() : void 0;
      });
    },
    copyMetadata: copyMetadata = function(input, output) {
      var file, from, to, _i, _len, _ref, _results;
      _ref = ["package.json", "README.md"];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        from = np.join(input, file);
        to = np.join(output, file);
        if (fs.existsSync(from)) {
          copy(from, to);
          _results.push(console.log("Copied " + to));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    buildCoffee: buildCoffee = function(input, output, callback) {
      return spawn("coffee.cmd -c -m -o " + output + " " + input, callback);
    },
    watchCoffee: watchCoffee = function(input, output) {
      return spawn("coffee.cmd -w -m -c -o " + output + " " + input);
    },
    isMatch: isMatch = function(value, match, defaultValue) {
      if (defaultValue == null) {
        defaultValue = false;
      }
      value = value.split(/[\/\\]/g).pop();
      if (match == null) {
        return defaultValue;
      }
      if ('function' === typeof match) {
        return match(value);
      }
      if (Array.isArray(match)) {
        return match.indexOf(value) >= 0;
      }
      if (typeof match === 'string') {
        return value.substring(value.length - match.length) === match;
      }
      return match.test(value);
    },
    defaultFileExclude: ["node_modules", "www"],
    touch: touch = function(file) {
      var now;
      now = new Date();
      return fs.utimesSync(file, now, now);
    },
    isFile: isFile = function(file) {
      var _ref;
      return ((_ref = fs.statSync(file)) != null ? typeof _ref.isFile === "function" ? _ref.isFile() : void 0 : void 0) === true;
    },
    isDirectory: isDirectory = function(file) {
      var _ref;
      return ((_ref = fs.statSync(file)) != null ? typeof _ref.isDirectory === "function" ? _ref.isDirectory() : void 0 : void 0) === true;
    },
    list: list = function(dir, options, files) {
      var exclude, file, recursive, _i, _len, _ref, _ref1, _ref2;
      if (options == null) {
        options = {};
      }
      if (files == null) {
        files = [];
      }
      exclude = (_ref = options.exclude) != null ? _ref : exports.defaultFileExclude;
      recursive = (_ref1 = options.recursive) != null ? _ref1 : true;
      _ref2 = fs.readdirSync(dir);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        file = _ref2[_i];
        file = np.join(dir, file);
        if (!isMatch(file, exclude, false)) {
          if (isFile(file)) {
            if (isMatch(file, options.include, true)) {
              files.push(file);
            }
          } else if (recursive) {
            list(file, options, files);
          }
        }
      }
      return files;
    },
    makeDirectories: makeDirectories = function(dir) {
      if (!Object.isString(dir)) {
        throw new Error("dir is not a string: " + (JSON.stringify(dir)));
      }
      if (!fs.existsSync(dir)) {
        makeDirectories(np.dirname(dir));
        return fs.mkdirSync(dir);
      }
    },
    makeParentDirectories: makeParentDirectories = function(file) {
      return makeDirectories(np.dirname(file));
    },
    read: read = function(file) {
      return fs.readFileSync(file, 'utf8');
    },
    write: write = function(file, content) {
      makeParentDirectories(file);
      return fs.writeFileSync(file, content, 'utf8');
    },
    copy: copy = function(source, target) {
      var content, file, files, _i, _len, _results;
      if (isFile(source)) {
        content = read(source);
        return write(target, content);
      } else if (isDirectory(source)) {
        files = fs.readdirSync(source);
        _results = [];
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          _results.push(copy(np.join(source, file), np.join(target, file)));
        }
        return _results;
      }
    },
    getMatches: function(s, regex, group) {
      var match, results;
      if (!regex.global) {
        throw 'regex must be declared with global modifier /trailing/g';
      }
      results = [];
      while (match = regex.exec(s)) {
        results.push(group > 0 ? match[group] : match);
      }
      return results;
    },
    startWebServer: function(config) {
      var app, express, http, port, root, server;
      if (!Object.isString(config.root)) {
        throw new Error("config.root string is required " + (JSON.stringify(config.root)));
      }
      if (!Object.isNumber(config.port)) {
        throw new Error("config.port number is required " + (JSON.stringify(config.port)));
      }
      root = config.root;
      port = config.port;
      express = require('express');
      app = express();
      http = require('http');
      app.disable('etag');
      app.configure(function() {
        app.use(function(req, res, next) {
          return next();
        });
        app.use(express["static"](root));
        return app.use(app.router);
      });
      server = http.createServer(app);
      server.listen(port);
      return console.log("Starting web server on port " + port + ".");
    }
  };

  if (typeof describe === 'function') {
    assert = require('assert');
    describe('glass.build.utility', function() {
      return describe('isMatch', function() {
        return it("should work", function() {
          assert(isMatch("foo.js", ".js"));
          assert(isMatch("foo.js", ["foo.bar", "foo.js"]));
          assert(isMatch("foo.js", /\.js$/));
          assert(isMatch("foo.js", function(x) {
            return x === "foo.js";
          }));
          assert(!isMatch("foo.jsp", ".js"));
          assert(!isMatch("foo.jsp", ["foo.bar", "foo.js"]));
          assert(!isMatch("foo.jsp", /\.js$/));
          return assert(!isMatch("foo.jsp", function(x) {
            return x === "foo.js";
          }));
        });
      });
    });
  }

}).call(this);

/*
//@ sourceMappingURL=utility.map
*/
